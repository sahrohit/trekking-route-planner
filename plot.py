import csv
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import argparse
from collections import defaultdict


def load_nodes(filename):
    """
    Parse nodes.csv and return a dict mapping node names to their attributes.
    """
    nodes = {}
    with open(filename, newline="") as f:
        reader = csv.DictReader(f)
        for row in reader:
            try:
                name = row["name"]
                lat = float(row["latitude"])
                lon = float(row["longitude"])
                alt = float(row["altitude"])
                imp = float(row["importance"])
            except KeyError as e:
                raise ValueError(f"Missing column in nodes CSV: {e}")
            except ValueError as e:
                raise ValueError(f"Invalid numeric value in nodes CSV: {e}")
            nodes[name] = {"lat": lat, "lon": lon, "alt": alt, "imp": imp}
    return nodes


def load_edges(filename, nodes):
    """
    Parse edges.csv and build a list of edges with coordinates.
    Returns list of tuples (source_coords, target_coords)
    """
    edges = []
    with open(filename, newline="") as f:
        reader = csv.DictReader(f)
        for row in reader:
            try:
                source = row["source"]
                target = row["target"]
            except KeyError as e:
                raise ValueError(f"Missing column in edges CSV: {e}")

            if source not in nodes or target not in nodes:
                continue

            source_coords = (nodes[source]["lon"], nodes[source]["lat"])
            target_coords = (nodes[target]["lon"], nodes[target]["lat"])
            edges.append((source_coords, target_coords))

    return edges


def load_path_data(filename):
    """
    Load path data from the CSV file generated by the path finder script.
    Returns a dictionary where keys are algorithm names and values are lists of node data.
    """
    path_data = defaultdict(list)

    with open(filename, newline="") as f:
        reader = csv.DictReader(f)
        for row in reader:
            algorithm = row["algorithm"]
            node_name = row["node"]
            lat = float(row["latitude"])
            lon = float(row["longitude"])
            path_data[algorithm].append((node_name, lon, lat))

    return path_data


def plot_map(nodes, edges, path_data, output_filename=None):
    """
    Create a map visualization showing all edges and the paths found by different algorithms.
    """
    fig, ax = plt.subplots(figsize=(12, 10))

    # Get coordinate ranges for better visualization
    lons = [node["lon"] for node in nodes.values()]
    lats = [node["lat"] for node in nodes.values()]
    lon_min, lon_max = min(lons), max(lons)
    lat_min, lat_max = min(lats), max(lats)

    # Add a bit of padding
    padding = 0.05
    lon_range = lon_max - lon_min
    lat_range = lat_max - lat_min
    lon_min -= padding * lon_range
    lon_max += padding * lon_range
    lat_min -= padding * lat_range
    lat_max += padding * lat_range

    # Plot all edges in light gray
    for (source_lon, source_lat), (target_lon, target_lat) in edges:
        ax.plot(
            [source_lon, target_lon],
            [source_lat, target_lat],
            "grey",
            alpha=0.3,
            linewidth=0.8,
        )

    # Plot all nodes as small black dots
    for node in nodes.values():
        ax.plot(node["lon"], node["lat"], "ko", markersize=2)

    # Define colors and line styles for different algorithms
    algorithm_styles = {
        "greedy": {"color": "red", "linestyle": "-."},
        "divide_and_conquer": {"color": "blue", "linestyle": "--"},
        "dynamic_programming": {"color": "green", "linestyle": "-"},
    }

    # Create legend handles
    legend_handles = [
        mpatches.Patch(color="grey", alpha=0.3, label="All Paths"),
    ]

    # Plot paths for each algorithm
    for algorithm, nodes_data in path_data.items():
        if not nodes_data:
            continue

        style = algorithm_styles.get(algorithm, {"color": "purple", "linestyle": ":"})
        legend_handles.append(
            mpatches.Patch(
                color=style["color"], label=algorithm.replace("_", " ").title()
            )
        )

        # Extract coordinates and connect the points
        coords = [(lon, lat) for _, lon, lat in nodes_data]
        for i in range(len(coords) - 1):
            lon1, lat1 = coords[i]
            lon2, lat2 = coords[i + 1]
            ax.plot(
                [lon1, lon2],
                [lat1, lat2],
                color=style["color"],
                linestyle=style["linestyle"],
                linewidth=2.5,
                alpha=0.8,  # Add transparency
            )

        # Add markers for start and end points
        start_name, start_lon, start_lat = nodes_data[0]
        end_name, end_lon, end_lat = nodes_data[-1]

        ax.plot(start_lon, start_lat, "o", color=style["color"], markersize=8)
        ax.plot(end_lon, end_lat, "*", color=style["color"], markersize=12)

        # Label start and end points
        ax.annotate(
            start_name,
            (start_lon, start_lat),
            xytext=(5, 5),
            textcoords="offset points",
            fontsize=9,
        )
        ax.annotate(
            end_name,
            (end_lon, end_lat),
            xytext=(5, 5),
            textcoords="offset points",
            fontsize=9,
        )

        # Label other points in the path
        for name, lon, lat in nodes_data[1:-1]:
            ax.annotate(
                name, (lon, lat), xytext=(3, 3), textcoords="offset points", fontsize=7
            )

    # Set axis limits
    ax.set_xlim(lon_min, lon_max)
    ax.set_ylim(lat_min, lat_max)

    # Add title and labels
    ax.set_title("Path Comparison Between Different Algorithms", fontsize=14)
    ax.set_xlabel("Longitude", fontsize=12)
    ax.set_ylabel("Latitude", fontsize=12)

    # Add legend
    ax.legend(handles=legend_handles, loc="best")

    # Add grid
    ax.grid(True, linestyle="--", alpha=0.7)

    # Adjust layout
    plt.tight_layout()

    # Save or show the figure
    if output_filename:
        plt.savefig(output_filename, dpi=300, bbox_inches="tight")
        print(f"Map saved as {output_filename}")
    else:
        plt.show()


def main():
    parser = argparse.ArgumentParser(description="Visualize paths on a map")
    parser.add_argument(
        "--nodes", default="dataset/nodes.csv", help="Path to nodes CSV file"
    )
    parser.add_argument(
        "--edges", default="dataset/edges.csv", help="Path to edges CSV file"
    )
    parser.add_argument(
        "--path-data", required=True, help="Path to the path data CSV file"
    )
    parser.add_argument("--output", help="Output filename for the map image (optional)")

    args = parser.parse_args()

    # Load data
    nodes = load_nodes(args.nodes)
    edges = load_edges(args.edges, nodes)
    path_data = load_path_data(args.path_data)

    # Generate the map
    output_filename = (
        args.output
        if args.output
        else args.path_data.replace("path_data_", "map_")
        .replace("/result", "/visualizations")
        .replace(".csv", ".png")
    )
    plot_map(nodes, edges, path_data, output_filename)


if __name__ == "__main__":
    main()
